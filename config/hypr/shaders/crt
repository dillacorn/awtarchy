#version 300 es
precision highp float;

in vec2 v_texcoord;
out vec4 FragColor;

uniform sampler2D tex;

/*
CRT-lite (brightness-neutral, low curvature, no time-based motion).
Defaults are intentionally subtle.

Tweak only these:
- CURVATURE:        0.0 = none, 0.004–0.012 = slight, 0.02+ = fish-eye
- SCANLINE_STRENGTH 0.00–0.08
- GRILLE_STRENGTH   0.00–0.20
- BLOOM_STRENGTH    0.00–0.12  (set 0.0 if you hate any “glow”)
- VIGNETTE_AMT      0.0 disables edge darkening entirely
*/

#define CURVATURE         0.008
#define SCANLINE_STRENGTH 0.045
#define GRILLE_STRENGTH   0.12
#define CONVERGENCE       0.00005
#define BLOOM_STRENGTH    0.06
#define GRAIN_STRENGTH    0.008
#define BLUR_MIX          0.10
#define CONTRAST          1.03
#define VIGNETTE_AMT      0.0
#define VIGNETTE_POWER    1.35

float hash12(vec2 p) {
    p = fract(p * vec2(123.34, 456.21));
    p += dot(p, p + 45.32);
    return fract(p.x * p.y);
}

vec2 curve(vec2 uv) {
    uv = uv * 2.0 - 1.0;
    uv *= 1.0 + (uv.yx * uv.yx) * CURVATURE;
    return uv * 0.5 + 0.5;
}

// Brightness-neutral scanline modulation (mean ~= 1.0)
float scanline(vec2 uv, vec2 res) {
    float y = uv.y * res.y;
    float phase = 6.2831853 * y;
    float s = cos(phase);                // [-1, 1], mean 0
    return 1.0 - SCANLINE_STRENGTH * (0.5 - 0.5 * s); // mostly darkening
}

// Brightness-neutral-ish aperture grille (mean ~= 1.0)
vec3 grille(vec2 uv, vec2 res) {
    float x = uv.x * res.x;
    float m = mod(floor(x), 3.0);

    vec3 mask = vec3(1.0);
    float a = GRILLE_STRENGTH;

    if (m < 0.5)       mask = vec3(1.0 + a, 1.0 - 0.5 * a, 1.0 - 0.5 * a);
    else if (m < 1.5)  mask = vec3(1.0 - 0.5 * a, 1.0 + a, 1.0 - 0.5 * a);
    else               mask = vec3(1.0 - 0.5 * a, 1.0 - 0.5 * a, 1.0 + a);

    return mask;
}

vec3 bloom4(vec2 uv, vec2 res) {
    vec2 o = vec2(1.0) / res;
    vec3 sum = vec3(0.0);
    sum += texture(tex, uv + vec2( o.x, 0.0)).rgb;
    sum += texture(tex, uv + vec2(-o.x, 0.0)).rgb;
    sum += texture(tex, uv + vec2(0.0,  o.y)).rgb;
    sum += texture(tex, uv + vec2(0.0, -o.y)).rgb;
    return sum * 0.25;
}

vec3 blur9(vec2 uv, vec2 res) {
    vec2 o = vec2(1.0) / res;
    vec3 sum = vec3(0.0);
    sum += texture(tex, uv + vec2(-o.x, -o.y)).rgb;
    sum += texture(tex, uv + vec2( 0.0, -o.y)).rgb;
    sum += texture(tex, uv + vec2( o.x, -o.y)).rgb;
    sum += texture(tex, uv + vec2(-o.x,  0.0)).rgb;
    sum += texture(tex, uv).rgb;
    sum += texture(tex, uv + vec2( o.x,  0.0)).rgb;
    sum += texture(tex, uv + vec2(-o.x,  o.y)).rgb;
    sum += texture(tex, uv + vec2( 0.0,  o.y)).rgb;
    sum += texture(tex, uv + vec2( o.x,  o.y)).rgb;
    return sum / 9.0;
}

float vignette(vec2 uv) {
    vec2 p = uv - 0.5;
    float r = dot(p, p) * 2.0;
    return pow(clamp(1.0 - r, 0.0, 1.0), VIGNETTE_POWER);
}

void main() {
    ivec2 ts = textureSize(tex, 0);
    vec2 res = vec2(max(ts.x, 1), max(ts.y, 1));

    vec2 uv = curve(v_texcoord);

    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
        FragColor = vec4(0.0);
        return;
    }

    vec3 base = texture(tex, uv).rgb;

    // subtle, static chroma convergence
    vec3 col;
    col.r = texture(tex, uv + vec2(CONVERGENCE, 0.0)).r;
    col.g = base.g;
    col.b = texture(tex, uv - vec2(CONVERGENCE, 0.0)).b;

    // effects (kept subtle and near brightness-neutral)
    col *= scanline(uv, res);
    col *= grille(uv, res);

    if (BLOOM_STRENGTH > 0.0) {
        col += bloom4(uv, res) * BLOOM_STRENGTH;
    }

    // static grain
    float g = hash12(floor(uv * res)) - 0.5;
    col += g * GRAIN_STRENGTH;

    // slight softness
    col = mix(col, blur9(uv, res), BLUR_MIX);

    // gentle contrast
    col = (col - 0.5) * CONTRAST + 0.5;

    // optional vignette (default off)
    if (VIGNETTE_AMT > 0.0) {
        col *= mix(1.0, vignette(uv), VIGNETTE_AMT);
    }

    FragColor = vec4(clamp(col, 0.0, 1.0), 1.0);
}
